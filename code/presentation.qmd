---
title: 'Gaussian Processes for Time Series Modelling'
author:
  - 'Azar Raphaela'
  - 'Gumede Sbonelo'
institute:  
  - 'University of Cape Town'
  - 'Supervisor: Dr. Birgit Erni'
date: today
format: 
  revealjs:
    incremental: true
    transition: fade
    css: styles.css
---

```{r Setup}
#| echo: FALSE
#| include: FALSE
#| warning: FALSE

options(repos=c(CRAN='https://cloud.r-project.org'))

packs=c('dplyr', 'forecast', 'fpp2', 'ggfortify', 'gifski', 'ggplot2', 'knitr', 
		  'splines', 'rstan')

for(pack in packs){
	if(!requireNamespace(pack, quietly=TRUE)){
		install.packages(pack, quiet=TRUE)
	}
	library(pack, character.only=TRUE)
}
```

## Plot of the dataset

```{r EDA}
#| echo: FALSE
#| warning: FALSE

df <- EuStockMarkets[, 'FTSE'] # Load data

autoplot(df) +
	labs(title='Daily Closing Prices of FTSE (1991-1998)',
		  x='Time',
		  y='FTSE') + 
	theme_minimal()
```

```{r Partition}
#| echo: FALSE
#| warning: FALSE

n <- length(df) # Number of observations in the data
train_end_index <- floor(0.7 * n) # (70/30)% split of the data

train <- window(df, end = time(df)[train_end_index]) # Training data
test <- window(df, start = time(df)[train_end_index + 1]) # Testing data
```

## B-splines

### Base case

$$
B_{i, 0}(t) := 
\begin{cases} 
	1, & \text{if } t_{i} \leq t < t_{i+1} \\
	0, & \text{otherwise}
\end{cases}
$$

### Recursive step

$$
B_{i,p}(t) := 
\frac{t - t_{i}}{t_{i+p} - t_{i}} B_{i, p-1}(t) 
+ \frac{t_{i+p+1}-t}{t_{i+p+1}-t_{i+1}} B_{i+1, p-1}(t)
$$

#### Where

$t$ is the covariate and $p$ is the degree of the polynomial.

```{r Decompose}
#| echo: FALSE
#| eval: FALSE

decomp_model <- decompose(train, type='multiplicative') # Decompose the training data
trend <- na.omit(decomp_model) # Remove missing values
n_old <- length(decomp$trend)
n_new <- length(trend)
time <- 131 : (n_new - 130) # First and last 130 observations are NA
linear <- lm(trend ~ time)
```

```{r Spline-Animation}
#| echo: FALSE
#| eval: TRUE
#| include: FALSE
#| warning: FALSE

train_time <- as.numeric(time(train)) # Extract the time component for training data
test_time <- as.numeric(time(test)) # Extract the time component for testing data

for(dof in 2:10){
	spline_model <- lm(train ~ bs(train_time, df=dof)) # Fit a spline model of degree 2
	train_preds <- predict(spline_model, newdata=data.frame(train_time=train_time)) # Spline on training data
	test_preds <- predict(spline_model, newdata=data.frame(train_time=test_time)) # Extrapolate
	train_ts <- ts(train_preds, start=start(train), frequency=frequency(train)) # Convert to ts
	test_ts <- ts(test_preds, start=start(test), frequency=frequency(test))
	
	p <- autoplot(df) +
		autolayer(train_ts, series='Train Spline', size=1.5) +
		autolayer(test_ts, series='Test Spline', size=1.5) +
		scale_color_manual(values=c('Train Spline'='lightskyblue', 
											 'Test Spline'='darkorange')) +
		labs(title='Daily Closing Prices of FTSE (1991-1998)',
			  x='Time',
			  y='FTSE',
			  color='Legend') + 
		theme_minimal() +
		theme(legend.text = element_text(size = 14), 
				legend.title = element_text(size = 16))
	ggsave(sprintf('../images/frame%02d.png', dof), p, width=12, height=8, dpi=300)
	}

png_files <- list.files('../images', full.names=TRUE)
gifski(png_files, gif_file='spline_animation.gif', width=1200, height=800, delay=1)
```

## Spline Animation

![](spline_animation.gif)

## Discussion

### Problem

Splines do not consider the correlations between data points. 
They model the immediate shape of the data.

### Solution

Use Gaussian processes to model the data generating process. 
GPs consider all the observations and their correlations.

## Gaussian process

### Definition

A time continuous stochastic process $\{X_{t}; \ t \in T\}$ is Gaussian 
if and only if for every finite set of indices $t_{1},...,t_{k}$ in the index set $T$
$$\mathbf{X}_{t_{1},...,t_{k}} = (X_{t_{1}},...,X_{t_{k}})$$
is a multivariate Gaussian random variable.

### Meaning

$$f \sim GP(m, k) \rightarrow f_{n} \sim MVN(\mathbf{m}, \mathbf{K})$$
$$\pi(y_{n};f(x_{n}),\phi) \rightarrow \pi(y_{n}; f_{n}, \phi)$$

## Mean Vector

$$
\mathbf{m} =
\begin{bmatrix}
\mu(x_{1}^{\text{obs}}) \\
\vdots \\
\mu(x_{N_{\text{obs}}}^{\text{obs}})  \\
\mu(x_{1}^{\text{pred}})\\
\vdots \\
\mu(x_{N_{\text{pred}}}^{\text{pred}})
\end{bmatrix}
$$

## Covariance-Matrix

$$
\mathbf{K} = 
\begin{bmatrix}
k(x_{1}^{\text{obs}}, x_{1}^{\text{obs}}) & \cdots & k(x_{1}^{\text{obs}}, x_{N_{\text{obs}}}^{\text{obs}}) & \quad & k(x_{1}^{\text{obs}}, x_{1}^{\text{pred}}) & \cdots & k(x_{1}^{\text{obs}}, x_{N_{\text{pred}}}^{\text{pred}}) \\
\vdots & \ddots & \vdots & & \vdots & \ddots & \vdots \\
k(x_{N_{\text{obs}}}^{\text{obs}}, x_{1}^{\text{obs}}) & \cdots & k(x_{N_{\text{obs}}}^{\text{obs}}, x_{N_{\text{obs}}}^{\text{obs}}) & \quad & k(x_{N_{\text{obs}}}^{\text{obs}}, x_{1}^{\text{pred}}) & \cdots & k(x_{N_{\text{obs}}}^{\text{obs}}, x_{N_{\text{pred}}}^{\text{pred}}) \\
k(x_{1}^{\text{pred}}, x_{1}^{\text{obs}}) & \cdots & k(x_{1}^{\text{pred}}, x_{N_{\text{obs}}}^{\text{obs}}) & \quad & k(x_{1}^{\text{pred}}, x_{1}^{\text{pred}}) & \cdots & k(x_{1}^{\text{pred}}, x_{N_{\text{pred}}}^{\text{pred}}) \\
\vdots & \ddots & \vdots & & \vdots & \ddots & \vdots \\
k(x_{N_{\text{pred}}}^{\text{pred}}, x_{1}^{\text{obs}}) & \cdots & k(x_{N_{\text{pred}}}^{\text{pred}}, x_{N_{\text{obs}}}^{\text{obs}}) & \quad & k(x_{N_{\text{pred}}}^{\text{pred}}, x_{1}^{\text{pred}}) & \cdots & k(x_{N_{\text{pred}}}^{\text{pred}}, x_{N_{\text{pred}}}^{\text{pred}})
\end{bmatrix}
$$

```{r GP}
#| echo: FALSE
#| warning: FALSE
#| eval: FALSE
rstan_options(auto_write=TRUE)
options(mc.cores=parallel::detectCores())
parallel:::setDefaultClusterOptions(setup_strategy='sequential')

util <- new.env()

par(family='serif', las=1, bty='l', cex.axis=1, cex.lab=1,
	 cex.main=1, xaxs='i', yaxs='i', mar=c(5, 5, 3, 5))

# Gram grid
x <- 22 * (0:(n-1)) / (n-1) - 11

# Parameters that specify our GP
alpha_true <- 3
rho_true <- 5.5
sigma_true <- 2

# Pack everything together
simu_data <- list(alpha=alpha_true, rho=rho_true, sigma=sigma_true, 
						N=n, x=x)

# Sample from the MVN(0, Gram-matrix)
simu_fit <- stan(file='stan_programs/presentation.stan', 
					  data=simu_data, warmup=0, iter=4000, chains=1, 
					  seed=494838, algorithm='Fixed_param', refresh=0, 
					  verbose=FALSE)

# Visualization code
source('gp_utility.R', local=util)
```

## Prior realizations

```{r PR}
#| echo: FALSE
#| warning: FALSE
#| eval: FALSE
util$plot_gp_prior_realizations(simu_fit, x, 'Prior realizations')
```

## Prior quantiles

```{r PQ}
#| echo: FALSE
#| warning: FALSE
#| eval: FALSE
util$plot_gp_prior_quantiles(simu_fit, x, 'Prior quantiles')
```
