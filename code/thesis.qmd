---
title: "THESIS"
format: html
---

SECTION 2: kERNELS

2.1 KE kernel 
```{r}
# ==============================
# Gaussian Process Prior Sampling
# ==============================

library(MASS)     # mvrnorm
library(ggplot2)  
library(gridExtra)

# Squared Exponential kernel function
se_kernel <- function(x, alpha, rho) {
  n <- length(x)
  K <- matrix(0, n, n)
  for (i in 1:n) {
    for (j in 1:n) {
      K[i,j] <- alpha^2 * exp(- ( (x[i]-x[j])^2 ) / (2*rho^2))
    }
  }
  return(K)
}

# Generate GP prior samples
gp_prior_samples <- function(x, alpha, rho, n_samp = 10) {
  K <- se_kernel(x, alpha, rho)
  mvrnorm(n_samp, mu = rep(0, length(x)), Sigma = K)
}

# X values
x <- seq(-5, 5, length.out = 100)

# Parameter grid
alphas <- c(0.5, 1.0, 2.0)  # small, medium, large variance
rhos   <- c(0.3, 1.0, 3.0)  # small, medium, large lengthscale

# Plotting function
plot_gp <- function(samples, x, title) {
  df <- data.frame(x = rep(x, nrow(samples)),
                   y = as.vector(t(samples)),
                   id = rep(1:nrow(samples), each=length(x)))
  ggplot(df, aes(x=x, y=y, group=id)) +
    geom_line(alpha=0.5, color="brown") +
    theme_minimal() +
    labs(title=title, x="x", y="f(x)") +
    theme(plot.title = element_text(hjust=0.5))
}

# Generate the 3x3 grid
plots <- list()
for (i in 1:3) {
  for (j in 1:3) {
    samp <- gp_prior_samples(x, alpha=alphas[i], rho=rhos[j], n_samp=10)
    title <- paste0(c("Small","Medium","Large")[i], " α, ",
                    c("Small","Medium","Large")[j], " ρ")
    plots[[length(plots)+1]] <- plot_gp(samp, x, title)
  }
}

# Arrange into grid
grid.arrange(grobs=plots, ncol=3)

```

2.2 Matern kernel 


```{r}
# ==============================
# Gaussian Process Prior Sampling (Matérn Kernel)
# ==============================

library(MASS)     
library(ggplot2)  
library(gridExtra)

# Matérn kernel function (nu = 1.5, but you can switch)
matern_kernel <- function(x, alpha, rho, nu=1.5) {
  n <- length(x)
  K <- matrix(0, n, n)
  for (i in 1:n) {
    for (j in 1:n) {
      d <- abs(x[i] - x[j])
      if (nu == 0.5) {
        K[i,j] <- alpha^2 * exp(-d / rho)
      } else if (nu == 1.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(3) * d / rho) * exp(-sqrt(3) * d / rho)
      } else if (nu == 2.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(5) * d / rho + 5 * d^2 / (3*rho^2)) * exp(-sqrt(5) * d / rho)
      } else {
        stop("Use nu = 0.5, 1.5, or 2.5")
      }
    }
  }
  return(K)
}

# Generate GP prior samples (Matérn)
gp_prior_samples_matern <- function(x, alpha, rho, nu=1.5, n_samp = 10) {
  K <- matern_kernel(x, alpha, rho, nu)
  mvrnorm(n_samp, mu = rep(0, length(x)), Sigma = K)
}

# X values
x <- seq(-5, 5, length.out = 100)

# Parameter grid
alphas <- c(0.5, 1.0, 2.0)  
rhos   <- c(0.3, 1.0, 3.0)  

# Plotting function (same as SE)
plot_gp <- function(samples, x, title) {
  df <- data.frame(x = rep(x, nrow(samples)),
                   y = as.vector(t(samples)),
                   id = rep(1:nrow(samples), each=length(x)))
  ggplot(df, aes(x=x, y=y, group=id)) +
    geom_line(alpha=0.5, color="brown") +
    theme_minimal() +
    labs(title=title, x="x", y="f(x)") +
    theme(plot.title = element_text(hjust=0.5))
}

# Generate the 3x3 grid
plots <- list()
for (i in 1:3) {
  for (j in 1:3) {
    samp <- gp_prior_samples_matern(x, alpha=alphas[i], rho=rhos[j], nu=1.5, n_samp=10)
    title <- paste0(c("Small","Medium","Large")[i], " α, ",
                    c("Small","Medium","Large")[j], " ρ (ν=1.5)")
    plots[[length(plots)+1]] <- plot_gp(samp, x, title)
  }
}

# Arrange into grid
grid.arrange(grobs=plots, ncol=3)

```
```{r}

# ==============================
# Matérn Family Comparison (Fixed Scales)
# ==============================

library(MASS)     
library(ggplot2)  
library(gridExtra)

# Matérn kernel function
matern_kernel <- function(x, alpha, rho, nu) {
  n <- length(x)
  K <- matrix(0, n, n)
  for (i in 1:n) {
    for (j in 1:n) {
      d <- abs(x[i] - x[j])
      if (nu == 0.5) {
        K[i,j] <- alpha^2 * exp(-d / rho)
      } else if (nu == 1.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(3)*d/rho) * exp(-sqrt(3)*d/rho)
      } else if (nu == 2.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(5)*d/rho + 5*d^2/(3*rho^2)) * exp(-sqrt(5)*d/rho)
      } else if (is.infinite(nu)) { 
        K[i,j] <- alpha^2 * exp(- (d^2)/(2*rho^2)) # SE kernel
      }
    }
  }
  return(K)
}

# Generate GP samples
gp_prior_samples_matern <- function(x, alpha, rho, nu, n_samp = 20) {
  K <- matern_kernel(x, alpha, rho, nu)
  mvrnorm(n_samp, mu = rep(0, length(x)), Sigma = K)
}

# Plotting function with fixed y-axis
plot_gp <- function(samples, x, nu, alpha, rho, ylim=c(-7,7)) {
  df <- data.frame(x = rep(x, nrow(samples)),
                   y = as.vector(t(samples)),
                   id = rep(1:nrow(samples), each=length(x)))
  title_text <- ifelse(is.infinite(nu),
                       paste0("Matérn Family\nν = ∞, α = ", alpha, ", ρ = ", rho),
                       paste0("Matérn Family\nν = ", nu, ", α = ", alpha, ", ρ = ", rho))
  
  ggplot(df, aes(x=x, y=y, group=id)) +
    geom_line(alpha=0.6, color="brown", linewidth=0.5) +
    theme_minimal(base_size = 14) +
    labs(title=title_text, x="x", y="f(x)") +
    theme(plot.title = element_text(hjust=0.5),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_line(color="grey85")) +
    coord_cartesian(ylim=ylim)  # FIXED scale
}

# X values
x <- seq(-5, 5, length.out = 100)

# Parameters
alpha <- 3
rho   <- 5.5
nus   <- c(0.5, 2.5, Inf)   # ν values to compare

# Generate plots
plots <- list()
for (nu in nus) {
  samp <- gp_prior_samples_matern(x, alpha=alpha, rho=rho, nu=nu, n_samp=20)
  plots[[length(plots)+1]] <- plot_gp(samp, x, nu, alpha, rho, ylim=c(-7,7))
}

# Arrange side-by-side
grid.arrange(grobs=plots, ncol=3)


```

```{r}
# ==============================
# Matérn Kernel Hyperparameter Grid
# ==============================

library(MASS)
library(ggplot2)
library(gridExtra)

# Matérn kernel function
matern_kernel <- function(x, alpha, rho, nu) {
  n <- length(x)
  K <- matrix(0, n, n)
  for (i in 1:n) {
    for (j in 1:n) {
      d <- abs(x[i] - x[j])
      if (nu == 0.5) {
        K[i,j] <- alpha^2 * exp(-d / rho)
      } else if (nu == 1.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(3)*d/rho) * exp(-sqrt(3)*d/rho)
      } else if (nu == 2.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(5)*d/rho + 5*d^2/(3*rho^2)) * exp(-sqrt(5)*d/rho)
      } else if (is.infinite(nu)) {
        K[i,j] <- alpha^2 * exp(- (d^2)/(2*rho^2))  # SE kernel
      }
    }
  }
  return(K)
}

# GP prior samples
gp_prior_samples_matern <- function(x, alpha, rho, nu, n_samp = 10) {
  K <- matern_kernel(x, alpha, rho, nu)
  mvrnorm(n_samp, mu = rep(0, length(x)), Sigma = K)
}

# Plotting function
plot_gp <- function(samples, x, alpha, rho, nu, ylim=c(-7,7)) {
  df <- data.frame(x = rep(x, nrow(samples)),
                   y = as.vector(t(samples)),
                   id = rep(1:nrow(samples), each=length(x)))
  
  title_text <- ifelse(is.infinite(nu),
                       paste0("ν = ∞, α=", alpha, ", ρ=", rho),
                       paste0("ν=", nu, ", α=", alpha, ", ρ=", rho))
  
  ggplot(df, aes(x=x, y=y, group=id)) +
    geom_line(alpha=0.6, color="brown", linewidth=0.5) +
    theme_minimal(base_size = 12) +
    labs(title=title_text, x="x", y="f(x)") +
    theme(plot.title = element_text(hjust=0.5, size=10),
          axis.title = element_text(size=9),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_line(color="grey90")) +
    coord_cartesian(ylim=ylim)
}

# X values
x <- seq(-5, 5, length.out = 100)

# Parameters: small / medium / large
alphas <- c(0.5, 1.5, 3.0)
rhos   <- c(0.5, 2.0, 5.0)

# Choose ν (can repeat for each: 0.5, 2.5, ∞)
nu <- 2.5  

# Generate plots for all (alpha, rho) pairs
plots <- list()
for (i in 1:3) {
  for (j in 1:3) {
    samp <- gp_prior_samples_matern(x, alpha=alphas[i], rho=rhos[j], nu=nu, n_samp=10)
    plots[[length(plots)+1]] <- plot_gp(samp, x, alphas[i], rhos[j], nu)
  }
}

# Arrange into 3x3 grid
grid.arrange(grobs=plots, ncol=3)

```
```{r}
# ==============================
# Matérn Kernel Grid (ν as rows, ρ as columns, α inside panels)
# ==============================

library(MASS)
library(ggplot2)
library(gridExtra)

# Matérn kernel function
matern_kernel <- function(x, alpha, rho, nu) {
  n <- length(x)
  K <- matrix(0, n, n)
  for (i in 1:n) {
    for (j in 1:n) {
      d <- abs(x[i] - x[j])
      if (nu == 0.5) {
        K[i,j] <- alpha^2 * exp(-d / rho)
      } else if (nu == 1.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(3)*d/rho) * exp(-sqrt(3)*d/rho)
      } else if (nu == 2.5) {
        K[i,j] <- alpha^2 * (1 + sqrt(5)*d/rho + 5*d^2/(3*rho^2)) * exp(-sqrt(5)*d/rho)
      } else if (is.infinite(nu)) {
        K[i,j] <- alpha^2 * exp(- (d^2)/(2*rho^2))  # SE kernel
      }
    }
  }
  return(K)
}

# GP prior samples
gp_prior_samples_matern <- function(x, alpha, rho, nu, n_samp = 5) {
  K <- matern_kernel(x, alpha, rho, nu)
  mvrnorm(n_samp, mu = rep(0, length(x)), Sigma = K)
}

# Plotting function
plot_gp <- function(samples, x, alpha, rho, nu, ylim=c(-7,7)) {
  df <- data.frame(x = rep(x, nrow(samples)),
                   y = as.vector(t(samples)),
                   id = rep(1:nrow(samples), each=length(x)))
  
  title_text <- ifelse(is.infinite(nu),
                       bquote(nu == infinity ~ ", α=" ~ .(alpha) ~ ", ρ=" ~ .(rho)),
                       bquote(nu == .(nu) ~ ", α=" ~ .(alpha) ~ ", ρ=" ~ .(rho)))
  
  ggplot(df, aes(x=x, y=y, group=id)) +
    geom_line(alpha=0.6, color="brown") +
    theme_minimal(base_size = 12) +
    labs(title=title_text, x="x", y="f(x)") +
    theme(plot.title = element_text(hjust=0.5, size=10),
          axis.title = element_text(size=9),
          panel.grid.minor = element_blank(),
          panel.grid.major = element_line(color="grey90")) +
    coord_cartesian(ylim=ylim)
}

# X values
x <- seq(-5, 5, length.out = 100)

# Parameters
alphas <- c(0.5, 1.5, 3.0)   # small, medium, large variance
rhos   <- c(0.5, 2.0, 5.0)   # small, medium, large lengthscale
nus    <- c(0.5, 2.5, Inf)   # smoothness levels

# Generate plots
plots <- list()
for (nu in nus) {
  for (rho in rhos) {
    # inside each panel, overlay curves for multiple α
    df_all <- data.frame()
    for (alpha in alphas) {
      samp <- gp_prior_samples_matern(x, alpha=alpha, rho=rho, nu=nu, n_samp=3)
      df <- data.frame(x = rep(x, nrow(samp)),
                       y = as.vector(t(samp)),
                       id = paste0("α=", alpha, "_", rep(1:nrow(samp), each=length(x))))
      df$alpha <- alpha
      df_all <- rbind(df_all, df)
    }
    
    title_text <- ifelse(is.infinite(nu),
                         paste0("ν = ∞, ρ = ", rho),
                         paste0("ν = ", nu, ", ρ = ", rho))
    
    p <- ggplot(df_all, aes(x=x, y=y, group=id, color=factor(alpha))) +
      geom_line(alpha=0.6) +
      scale_color_manual(values=c("darkgreen","blue","darkred")) +
      theme_minimal(base_size = 12) +
      labs(title=title_text, x="x", y="f(x)", color="α") +
      theme(plot.title = element_text(hjust=0.5, size=10),
            axis.title = element_text(size=9),
            panel.grid.minor = element_blank(),
            panel.grid.major = element_line(color="grey90"))
    
    plots[[length(plots)+1]] <- p
  }
}

# Arrange into 3x3 grid
grid.arrange(grobs=plots, ncol=3)

```
```{r}
# Libraries
library(ggplot2)
library(gridExtra)
library(MASS)      # for mvrnorm

# Matern kernel function
matern_cov <- function(x, nu, alpha, rho) {
  d <- as.matrix(dist(x))
  if (is.infinite(nu)) { # SE kernel case
    K <- alpha^2 * exp(- (d^2) / (2 * rho^2))
  } else {
    # Use Bessel function of the second kind
    K <- (alpha^2) * (2^(1-nu))/gamma(nu) *
      (sqrt(2*nu) * d / rho)^nu *
      besselK(sqrt(2*nu) * d / rho, nu)
    diag(K) <- alpha^2
    K[is.na(K)] <- alpha^2
  }
  return(K)
}

# Parameters
x <- seq(-5, 5, length.out = 100)
nus <- c(0.5, 2.5, Inf)
alphas <- c(0.5, 1.5, 3)
rhos <- c(0.5, 2, 5)

# Simulate functions for each combo
set.seed(123)
n_funcs <- 10
df_list <- list()

for (nu in nus) {
  for (alpha in alphas) {
    for (rho in rhos) {
      K <- matern_cov(x, nu, alpha, rho)
      sims <- mvrnorm(n_funcs, mu = rep(0, length(x)), Sigma = K)
      tmp <- data.frame(
        x = rep(x, n_funcs),
        f = as.vector(t(sims)),
        func = rep(1:n_funcs, each = length(x)),
        nu = paste0("ν = ", ifelse(is.infinite(nu), "∞", nu)),
        alpha = paste0("α = ", alpha),
        rho = paste0("ρ = ", rho)
      )
      df_list[[length(df_list)+1]] <- tmp
    }
  }
}
df <- do.call(rbind, df_list)

# Plot
ggplot(df, aes(x, f, group = func)) +
  geom_line(alpha = 0.5, color = "brown") +
  facet_grid(alpha ~ nu + rho, labeller = label_value) +
  theme_minimal(base_size = 12) +
  labs(x = "x", y = "f(x)", 
       title = "Matérn Kernel Samples across ν, α, ρ")

```

Hyper-parameter tuning 
```{r}
# Load libraries
library(MASS)      # for mvrnorm
library(ggplot2)

# Squared Exponential (SE) kernel for simplicity
se_kernel <- function(x, rho, alpha = 1) {
  d <- as.matrix(dist(x))
  K <- alpha^2 * exp(-(d^2) / (2 * rho^2))
  return(K)
}

# Log marginal likelihood function
log_marginal_likelihood <- function(X, y, rho, alpha = 1, sigma_n = 0.1) {
  K <- se_kernel(X, rho, alpha) + sigma_n^2 * diag(length(X))
  L <- chol(K)  # Cholesky decomposition
  alpha_vec <- backsolve(t(L), forwardsolve(L, y))
  
  lml <- -0.5 * t(y) %*% alpha_vec -
         sum(log(diag(L))) -
         (length(X) / 2) * log(2 * pi)
  
  return(as.numeric(lml))
}

# Simulate data
set.seed(123)
X <- seq(-5, 5, length.out = 30)
true_rho <- 1.5
true_alpha <- 1.0
sigma_n <- 0.1

K_true <- se_kernel(X, true_rho, true_alpha) + sigma_n^2 * diag(length(X))
y <- mvrnorm(1, rep(0, length(X)), K_true)

# Evaluate LML across a grid of rho values
rho_vals <- seq(0.1, 5, length.out = 100)
lml_vals <- sapply(rho_vals, function(r) 
  log_marginal_likelihood(X, y, r, alpha = true_alpha, sigma_n = sigma_n)
)

# Put into a dataframe
df <- data.frame(rho = rho_vals, LML = lml_vals)

# Plot
ggplot(df, aes(rho, LML)) +
  geom_line(color = "brown", size = 1) +
  geom_vline(xintercept = true_rho, linetype = "dashed", color = "blue") +
  theme_minimal(base_size = 14) +
  labs(x = expression(rho), 
       y = "Log Marginal Likelihood",
       title = "Log Marginal Likelihood vs. Lengthscale")

```

```{r}
library(MASS)     # for mvrnorm
library(ggplot2)

# --- Kernel functions ---
se_kernel <- function(x, rho, alpha = 1) {
  d <- as.matrix(dist(x))
  K <- alpha^2 * exp(-(d^2) / (2 * rho^2))
  return(K)
}

matern_kernel <- function(x, rho, alpha = 1, nu = 2.5) {
  d <- as.matrix(dist(x))
  if (nu == 0.5) {
    K <- alpha^2 * exp(-d / rho)
  } else if (nu == 1.5) {
    K <- alpha^2 * (1 + sqrt(3) * d / rho) * exp(-sqrt(3) * d / rho)
  } else if (nu == 2.5) {
    K <- alpha^2 * (1 + sqrt(5) * d / rho + (5 * d^2) / (3 * rho^2)) *
         exp(-sqrt(5) * d / rho)
  } else if (is.infinite(nu)) {
    K <- alpha^2 * exp(-(d^2) / (2 * rho^2))  # SE as ν → ∞
  } else {
    stop("Only ν = 0.5, 1.5, 2.5, ∞ implemented.")
  }
  return(K)
}

# --- Log marginal likelihood ---
log_marginal_likelihood <- function(K, y, sigma2 = 1e-4) {
  n <- length(y)
  Ky <- K + sigma2 * diag(n)
  L <- chol(Ky)
  alpha <- backsolve(t(L), forwardsolve(L, y))
  logdet <- 2 * sum(log(diag(L)))
  lml <- -0.5 * t(y) %*% alpha - 0.5 * logdet - (n / 2) * log(2 * pi)
  return(lml)
}

# --- Generate toy dataset ---
set.seed(42)
x <- seq(-5, 5, length.out = 20)
y <- sin(x) + rnorm(length(x), 0, 0.1)

# --- Sweep over rho values ---
rhos <- seq(0.1, 5, length.out = 50)
results <- data.frame()

kernels <- list(
  list(name = "SE (ν=∞)", nu = Inf),
  list(name = "Matérn ν=0.5", nu = 0.5),
  list(name = "Matérn ν=1.5", nu = 1.5),
  list(name = "Matérn ν=2.5", nu = 2.5)
)

for (ker in kernels) {
  for (rho in rhos) {
    K <- matern_kernel(x, rho, nu = ker$nu)
    lml <- log_marginal_likelihood(K, y)
    results <- rbind(results,
                     data.frame(rho = rho,
                                lml = lml,
                                kernel = ker$name))
  }
}

# --- Plot ---
ggplot(results, aes(x = rho, y = lml, color = kernel)) +
  geom_line(size = 1) +
  theme_minimal(base_size = 14) +
  labs(x = expression(rho~"(lengthscale)"),
       y = "Log Marginal Likelihood",
       title = "LML curves for SE and Matérn kernels",
       color = "Kernel")

```

