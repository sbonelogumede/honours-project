---
title: "Simulation + EDA"
format: html
editor: visual
---

# Chapter 4: Exploratory Data Analysis and Simulation Design

To build a simulation that closely replicates the empirical characteristics of the gold-like closing price dataset, we performed exploratory data analysis (EDA) on the true historical closing price data provided in `FINAL_USO.csv`. The analysis was supported by summary statistics, autocorrelation diagnostics, and rolling volatility indicators.

### 4.1 Closing Price Dynamics

```{r, fig.cap="Figure 4.1: Daily gold-like closing price (USD). The series shows a downward trend between 2012–2015, followed by sideways fluctuations with irregular volatility."}

library(tidyverse)
library(zoo)
library(lubridate)

# Load the data
df <- read_csv("FINAL_USO.csv") %>%
  mutate(Date = as.Date(Date)) %>%
  arrange(Date)

# Plot closing price
ggplot(df, aes(x = Date, y = Close)) +
  geom_line(color = "goldenrod", size = 0.5) +
  labs(
    title = "Gold-Like Closing Price (USD)",
    x = "Date", y = "Close Price (USD)"
  ) +
  theme_minimal(base_size = 14)

```

The series exhibits a downward trend between 2012 and 2016, followed by sideways fluctuations with irregular volatility. Importantly, there is no strong seasonal structure, and the series instead reflects regime shifts and bursts of volatility.

Recommendation: This behavior can be modeled with a piecewise deterministic drift or linearly declining trend to capture regime-dependent dynamics, a practice consistent with established time-series methodology (Hamilton, 1994).

### 4.2 Descriptive Statistics

```{r,fig.cap="Table 4.1: Descriptive statistics of the closing price series. Prices range mostly between $100 and $175, with a mean around $127, confirming bounded but non-stationary behavior."}
summary(df$Close)

```

On average, the closing price fluctuates between \$100 and \$175, with a long-run mean of approximately \$127. This confirms that the data are non-stationary, but still bounded within realistic market ranges for our selected time-frame.

### 4.3 Return Dynamics

```{r,fig.cap="Figure 4.2: Autocorrelation function (ACF) of log returns. Correlations are close to zero across lags, indicating weak serial dependence in returns."}

# Calculate log returns
df <- df %>%
  mutate(Returns = log(Close / lag(Close)))

# Plot autocorrelation of returns
acf(na.omit(df$Returns), main = "ACF of Log Returns")

```

The autocorrelation of log returns is very close to zero (-0.0688 at lag 1), suggesting returns are largely uncorrelated. This finding is consistent with the stylized facts of financial time series, where returns often behave like a noisy or random process (Cont, 2001).

Recommendation: Simulation can begin from a Geometric Brownian Motion (GBM) framework, while extending it with heteroskedastic components to capture volatility dynamics.

### 4.4 Rolling Mean and Volatility

```{r, fig.cap="Figure 4.3: Rolling 100-day mean (left) and rolling 100-day volatility (right). The rolling mean highlights long-term shifts in drift, while the rolling volatility shows alternating calm and turbulent periods."}
library(gridExtra)
# Compute rolling mean and volatility
df <- df %>%
  mutate(
    RollingMean = rollmean(Close, k = 100, fill = NA, align = "right"),
    RollingVol  = rollapply(Close, width = 100, FUN = sd, fill = NA, align = "right")
  )

# Rolling Mean plot
p1 <- ggplot(na.omit(df), aes(x = Date)) +
  geom_line(aes(y = Close), color = "gray", alpha = 0.4) +
  geom_line(aes(y = RollingMean), color = "blue", size = 1) +
  labs(title = "Rolling 100-Day Mean", y = "Price (USD)", x = "Date") +
  theme_minimal(base_size = 12)

# Rolling Volatility plot
p2 <- ggplot(na.omit(df), aes(x = Date, y = RollingVol)) +
  geom_line(color = "red", size = 1) +
  labs(title = "Rolling 100-Day Volatility", y = "Volatility", x = "Date") +
  theme_minimal(base_size = 12)

# Arrange side by side
grid.arrange(p1, p2, ncol = 2)

```

The rolling mean illustrates shifts in long-term drift, while the rolling standard deviation highlights volatility clustering — extended periods of calm alternating with periods of turbulence.

Recommendation: Such dynamics can be simulated using models that allow for time-varying variance, such as GARCH processes (Engle, 1982). This ensures the simulated series reflects the empirical volatility bursts observed in the data.

### 4.5 Summary of Findings

The EDA provides clear evidence of the following features:

Downward Drift (2012–2015):A piecewise deterministic trend should be included to replicate early decline (Hamilton, 1994).

Volatility Clustering: Heteroskedastic processes such as GARCH are necessary to model alternating calm and turbulent periods (Engle, 1982).

No Seasonality: The absence of seasonal effects supports excluding sine/cosine terms or seasonal ARIMA models (Cont, 2001).

Irregular Noise: Returns exhibit noisy, uncorrelated behavior, motivating stochastic simulation with mean-reverting adjustments (Rasmussen & Williams, 2006).

Together, these insights form the foundation for designing a simulation process that faithfully mirrors the empirical structure of the gold-like dataset, before applying Gaussian Process regression and other time-series forecasting methods.

###4.6 Simulation of a Gold-Like Time Series

We simulate a synthetic series that shares key properties of the real dataset. The simulation includes:

1.  Deterministic downward drift (linear decay in the early part).

2.  Stochastic noise with volatility bursts (to mimic clustering).

3.  No seasonal cycles (confirmed in EDA).

```{r, fig.cap="Figure 4.4: Simulated gold-like closing price series with downward drift, volatility clustering, and irregular fluctuations.", out.width="100%"}
library(ggplot2)
set.seed(123)

n <- nrow(df)             # same length as real data
time <- 1:n

# Piecewise deterministic trend: early downward, then flat
trend <- ifelse(time < 800,
                170 - 0.05 * time,    # downward drift
                130)                  # stabilized level

# Volatility clustering: alternate calm & turbulent regimes
vol <- rep(c(2, 6), length.out = n)   # switching volatility regimes

# Random noise with bursts
noise <- rnorm(n, mean = 0, sd = vol)

# Add weak mean-reversion to keep values bounded
sim_price <- trend + cumsum(noise * 0.2)

# Convert to data frame for plotting
sim_df <- data.frame(Date = df$Date, Sim_Close = sim_price)

# Plot
ggplot(sim_df, aes(x = Date, y = Sim_Close)) +
  geom_line(color = "darkgreen", size = 0.6) +
  labs(
    title = "Simulated Gold-Like Closing Price",
    x = "Date", y = "Simulated Close Price (USD)"
  ) +
  theme_minimal(base_size = 14)

```

The simulation produces a synthetic gold-like series of the same length as the real dataset. The first 800 days replicate the downward drift observed from 2012 to 2015. Thereafter, the process stabilizes around a constant level, reflecting the sideways dynamics from 2016 onward. Volatility clustering is incorporated by alternating between high- and low-variance noise regimes, which produces extended calm periods followed by turbulent fluctuations. Finally, a weak mean-reversion term ensures the process remains bounded between approximately 100 and 170 USD.

This simulated dataset will serve as a controlled environment for testing Gaussian Process models and comparing them against benchmark time-series methods.

```{r}
#Check mean prediction
library(kernlab)

# Prepare data for GP regression
x <- as.matrix(time)  # time index as input
y <- sim_price        # simulated closing prices

# Fit GP model (RBF kernel)
gp_model <- gausspr(x, y, kernel = "rbfdot")

# Predict (including on a test set if you wish)
y_pred <- predict(gp_model, x)

# Plot actual vs GP fit
plot(x, y, type = "l", col = "darkgreen", lwd = 2, main = "GP Fit to Simulated Gold Price")
lines(x, y_pred, col = "blue", lwd = 2)
legend("topleft", legend = c("Simulated", "GP fit"), col = c("darkgreen", "blue"), lty = 1, lwd = 2)

```

\
Bayesian Approach (Rstan)

```{r}


x <- sim_df$Date
y <- sim_df$Sim_Close

# It's strongly recommended to scale x and y for Stan numerical stability:
x_scaled <- as.numeric(scale(x))
y_scaled <- as.numeric(scale(y))
N <- length(x_scaled)

```

```{r}
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)

stan_data <- list(
  N = length(x),
  x = as.numeric(x),  # not as.matrix, not as.vector (if it's a matrix/column, use drop = TRUE)
  y = as.numeric(y)
)


fit <- stan(
  file = "gp_rbf.stan",
  data = stan_data,
  iter = 1000,
  chains = 4,
  seed = 42
)

print(fit, pars = c("alpha", "rho", "sigma"))

```

Marginal likelihood approach

```{r}
library(tidyverse)
library(kernlab)

# Simulate as before
set.seed(123)
df <- read_csv("FINAL_USO.csv") %>%
  mutate(Date = as.Date(Date)) %>%
  arrange(Date)
n <- nrow(df)
time <- 1:n

trend <- ifelse(time < 800,
                170 - 0.05 * time,
                130)
vol <- rep(c(2, 6), length.out = n)
noise <- rnorm(n, mean = 0, sd = vol)
sim_price <- trend + cumsum(noise * 0.2)
sim_df <- data.frame(Date = df$Date, Sim_Close = sim_price

```

```{r}
library(tidyverse)
library(kernlab)

# Simulate the series 
set.seed(123)
df <- read_csv("FINAL_USO.csv") %>%
  mutate(Date = as.Date(Date)) %>%
  arrange(Date)
n <- nrow(df)
time <- 1:n

trend <- ifelse(time < 800, 170 - 0.05 * time, 130)
vol <- rep(c(2, 6), length.out = n)
noise <- rnorm(n, mean = 0, sd = vol)
sim_price <- trend + cumsum(noise * 0.2)
sim_df <- data.frame(Time = time, Date = df$Date, Sim_Close = sim_price)

#  Fit a linear (drift) mean to the data 
lin_fit <- lm(Sim_Close ~ Time, data = sim_df)
mean_pred <- predict(lin_fit, newdata = sim_df)
resid_gp <- sim_df$Sim_Close - mean_pred

# Fit GP to the residuals 
x_mat <- as.matrix(sim_df$Time)
gp_fit <- gausspr(x = x_mat, y = resid_gp, kernel = "rbfdot")  # RBF kernel

#  Predict on all data (add mean function back)
gp_resid_pred <- predict(gp_fit, x_mat)
gp_total_pred <- mean_pred + gp_resid_pred

# Simulated series, drift fit, and GP+drift fit
library(ggplot2)
sim_df <- sim_df %>%
  mutate(
    Drift_Fit = mean_pred,
    GP_Drift_Fit = gp_total_pred
  )

ggplot(sim_df, aes(x = Date)) +
  geom_line(aes(y = Sim_Close), color = "darkgreen", size = 0.8, alpha = 0.7, linetype = "solid") +
  geom_line(aes(y = Drift_Fit), color = "blue", size = 1, linetype = "dashed") +
  geom_line(aes(y = GP_Drift_Fit), color = "red", size = 1.1, linetype = "solid") +
  labs(
    title = "Simulated Gold Price: True vs Drift Mean vs GP+Drift",
    y = "Simulated Close Price (USD)",
    x = "Date"
  ) +
  scale_color_manual(
    values = c("Simulated" = "darkgreen", "Drift Mean" = "blue", "GP+Drift" = "red")
  ) +
  theme_minimal(base_size = 14)



```

```{r}
library(tidyverse)
library(kernlab)
library(forecast)

# --- Hold-out last 30 for testing 
h <- 30
train_idx <- 1:(n - h)
test_idx  <- (n - h + 1):n
train <- sim_df[train_idx, ]
test  <- sim_df[test_idx, ]

# --- Mean model ---
mean_pred <- rep(mean(train$Sim_Close), h)

# --- Naive model (last observed value) ---
naive_pred <- rep(train$Sim_Close[nrow(train)], h)

# --- Seasonal naive (1 year = 252 days) ---
seasonal_period <- 252
seasonal_naive_pred <- if (nrow(train) >= seasonal_period) {
  train$Sim_Close[(nrow(train) - seasonal_period + 1):(nrow(train) - seasonal_period + h)]
} else {
  rep(mean(train$Sim_Close), h) 
}

# --- Drift model ---
drift_mod <- rwf(train$Sim_Close, h = h, drift = TRUE)
drift_pred <- as.numeric(drift_mod$mean)

# --- AR(1) model ---
ar_mod <- Arima(train$Sim_Close, order = c(1,0,0))
ar_pred <- as.numeric(forecast(ar_mod, h = h)$mean)

# --- GP + Drift 
# Fit drift (linear model) to training data
lin_fit <- lm(Sim_Close ~ Time, data = train)
drift_train <- predict(lin_fit, newdata = train)
drift_test  <- predict(lin_fit, newdata = test)
resid_gp <- train$Sim_Close - drift_train

# GP on training residuals
x_mat <- as.matrix(train$Time)
gp_fit <- gausspr(x = x_mat, y = resid_gp, kernel = "rbfdot")
gp_pred_train <- predict(gp_fit, x_mat)
gp_pred_test  <- predict(gp_fit, as.matrix(test$Time))

# GP+Drift prediction
gpdrift_pred <- drift_test + gp_pred_test

# --- Metrics function ---
metric_fun <- function(true, pred) {
  rmse <- sqrt(mean((true - pred)^2))
  mae  <- mean(abs(true - pred))
  mape <- mean(abs((true - pred) / true)) * 100
  c(RMSE = rmse, MAE = mae, MAPE = mape)
}

results <- tibble(
  Model  = c("Mean", "Naive", "Seasonal Naive", "Drift", "AR(1)", "GP+Drift"),
  RMSE   = c(
    metric_fun(test$Sim_Close, mean_pred)[1],
    metric_fun(test$Sim_Close, naive_pred)[1],
    metric_fun(test$Sim_Close, seasonal_naive_pred)[1],
    metric_fun(test$Sim_Close, drift_pred)[1],
    metric_fun(test$Sim_Close, ar_pred)[1],
    metric_fun(test$Sim_Close, gpdrift_pred)[1]
  ),
  MAE    = c(
    metric_fun(test$Sim_Close, mean_pred)[2],
    metric_fun(test$Sim_Close, naive_pred)[2],
    metric_fun(test$Sim_Close, seasonal_naive_pred)[2],
    metric_fun(test$Sim_Close, drift_pred)[2],
    metric_fun(test$Sim_Close, ar_pred)[2],
    metric_fun(test$Sim_Close, gpdrift_pred)[2]
  ),
  MAPE   = c(
    metric_fun(test$Sim_Close, mean_pred)[3],
    metric_fun(test$Sim_Close, naive_pred)[3],
    metric_fun(test$Sim_Close, seasonal_naive_pred)[3],
    metric_fun(test$Sim_Close, drift_pred)[3],
    metric_fun(test$Sim_Close, ar_pred)[3],
    metric_fun(test$Sim_Close, gpdrift_pred)[3]
  )
)

print(results, n = Inf)

```

cmdstanr:

```{r}
library(cmdstanr)
library(posterior)
library(bayesplot)

sim_df$Time <- as.numeric(sim_df$Date - min(sim_df$Date)) + 1
X <- matrix(sim_df$Time, ncol = 1)
y <- sim_df$Sim_Close
n <- nrow(sim_df)

```

```{r}
library(cmdstanr)
stan_data <- list(N = n, x = as.vector(X), y = y)

mod <- cmdstan_model("gp_regression.stan")
fit <- mod$sample(
  data = stan_data,
  seed = 2024,
  chains = 4,
  parallel_chains = 4,
  iter_warmup = 1000,
  iter_sampling = 1000,
  refresh = 500
)

```

### 4.7 Gaussian Process Modeling of Simulated Data

Following the exploratory analysis and simulation, we now fit a Gaussian Process (GP) model to the simulated gold-like closing price series. This follows the robust workflow outlined in Betancourt’s Robust Gaussian Process Modeling tutorial, which stresses:

1.  Careful data preprocessing (centering and scaling).
2.  Explicit kernel construction with priors on hyperparameters.
3.  Robust inference using cmdstanr.
4.  Posterior predictive checks with uncertainty quantification.

### 4.7.1 Data Preparation

Gaussian Processes assume stationarity in their kernels. Since our simulated series contains large offsets and long-term drift (identified in Section 4.6), we first center and scale the series to stabilize inference.

```{r}
library(cmdstanr)

# Standardize simulated price
y <- scale(sim_df$Sim_Close, center = TRUE, scale = TRUE)
x <- 1:length(y)

gp_data <- list(
  N = length(y),
  x = as.vector(x),
  y = as.vector(y)
)
```

### 4.7.2 Stan Model

We adopt the squared exponential (RBF) kernel, written explicitly as in Betancourt’s tutorial. Importantly, we parameterize hyperparameters on the log scale for stability, and use weakly informative priors to avoid pathological fits.

### 4.7.3 Model Fitting and Diagnostics

```{r}
# Compile Stan model
mod <- cmdstan_model("gp_model.stan")

# Sample
fit <- mod$sample(
  data = gp_data,
  seed = 2025,
  chains = 4,
  parallel_chains = 4,
  iter_sampling = 1000,
  iter_warmup = 1000,
  refresh = 500
)
```

### 4.7.4 Hyperparameter Analysis

```{r}
# Extract posterior samples
draws <- gp_fit$draws(format = "df")

# Hyperparameter posterior distributions

library(bayesplot)
mcmc_areas(draws, pars = c("rho", "alpha", "sigma")) +
  ggtitle("Posterior Distributions of GP Hyperparameters") +
  theme_minimal()
```

The length scale parameter rho controls the smoothness of the GP function - larger values indicate smoother functions. The amplitude parameter alpha controls the marginal standard deviation of the process. The noise parameter sigma captures measurement error.

### 4.7.5 Posterior Predictive Checks

Following Betancourt's emphasis on model validation, we perform posterior predictive checks:

```{r}
# Extract posterior predictive samples
y_rep <- draws %>% 
  select(starts_with("f_rep")) %>%
  as.matrix()

# Posterior predictive check
ppc_dens_overlay(gp_data$y, y_rep[1:100, ]) +
  ggtitle("Posterior Predictive Check: Density Overlay") +
  theme_minimal()

# Check key statistics
ppc_stat(gp_data$y, y_rep, stat = "mean") +
  ggtitle("PPC: Mean")

ppc_stat(gp_data$y, y_rep, stat = "sd") +
  ggtitle("PPC: Standard Deviation")
```

```{r}
# Load necessary libraries
library(forecast)
library(tidyverse)

# Assume sim_df already exists with Sim_Close and Date columns
sim_ts <- ts(sim_df$Sim_Close, frequency = 1)  # No seasonality, daily data

# Split data into train/test (e.g., last 100 points for testing)
n <- length(sim_ts)
train <- window(sim_ts, end = n - 100)
test <- window(sim_ts, start = n - 99)

# 1. Mean Forecast (Average)
mean_fit <- meanf(train, h = 100)

# 2. Naive Forecast
naive_fit <- naive(train, h = 100)

# 3. Drift Forecast
drift_fit <- rwf(train, h = 100, drift = TRUE)

# 4. ARIMA Forecast
arima_fit <- auto.arima(train)
arima_forecast <- forecast(arima_fit, h = 100)

# 5. GP Forecast (already generated earlier, assume vector `gp_forecast`)
# If in R: use colMeans(gp_fit$draws("f_rep", format = "matrix"))[(length(train)+1):(length(train)+100)]

# Combine forecasts into a tibble
forecasts <- tibble(
  Actual = as.numeric(test),
  Mean = as.numeric(mean_fit$mean),
  Naive = as.numeric(naive_fit$mean),
  Drift = as.numeric(drift_fit$mean),
  ARIMA = as.numeric(arima_forecast$mean)
)

# Evaluate performance
evaluate <- function(pred, actual) {
  tibble(
    RMSE = sqrt(mean((actual - pred)^2)),
    MAE = mean(abs(actual - pred)),
    R2 = cor(actual, pred)^2
  )
}

# Create performance table
performance <- bind_rows(
  evaluate(forecasts$Mean, forecasts$Actual),
  evaluate(forecasts$Naive, forecasts$Actual),
  evaluate(forecasts$Drift, forecasts$Actual),
  evaluate(forecasts$ARIMA, forecasts$Actual)
)

# Add model labels
performance <- cbind(Model = c("Mean", "Naive", "Drift", "ARIMA"), performance)

# Print performance table
print(performance)
```

llllllllllll

```{r}
sim_df <- read_csv("simulated_gold_prices.csv")
sim_df$Time <- as.numeric(sim_df$Date - min(as.Date(sim_df$Date))) + 1

n <- nrow(sim_df)
train_idx <- 1:(n - 30)      # all but last 30
test_idx <- (n - 29):n       # last 30 for forecast

X_train <- matrix(sim_df$Time[train_idx], ncol = 1)
y_train <- sim_df$Sim_Close[train_idx]
X_test  <- matrix(sim_df$Time[test_idx], ncol = 1)
y_test  <- sim_df$Sim_Close[test_idx]

# RBF kernel (default)
gp_model <- gausspr(
  x = X_train,
  y = y_train,
  kernel = "rbfdot"
)


```

```{r}
# In-sample fit
gp_fit <- predict(gp_model, X_train)

# Forecast (out-of-sample)
gp_forecast <- predict(gp_model, X_test)

```

```{r}
# Plot full fit and forecast
plot(sim_df$Time, sim_df$Sim_Close, type = "l", col = "darkgreen", lwd = 2,
     xlab = "Time", ylab = "Simulated Close Price", main = "GP Fit and Forecast")

lines(sim_df$Time[train_idx], gp_fit, col = "blue", lwd = 2)
lines(sim_df$Time[test_idx], gp_forecast, col = "red", lwd = 2)

abline(v = sim_df$Time[n - 30], col = "gray", lty = 2)
legend("topleft", legend = c("Simulated", "GP Fit", "GP Forecast"),
       col = c("darkgreen", "blue", "red"), lty = 1, lwd = 2)

```

\

```{r}
mse  <- mean((y_test - gp_forecast)^2)
mae  <- mean(abs(y_test - gp_forecast))
mape <- mean(abs((y_test - gp_forecast) / y_test)) * 100

cat(sprintf("Test MSE: %.3f, MAE: %.3f, MAPE: %.2f%%\n", mse, mae, mape))

```

```{r}
library(cmdstanr)

# Scale the time variable (important for GPs!)
sim_df$Time_scaled <- as.numeric(scale(as.numeric(sim_df$Date)))
N <- nrow(sim_df)

# Prepare data
stan_data <- list(
  N = N,
  x = sim_df$Time_scaled,
  y = sim_df$Sim_Close
)

# Compile the Stan model
mod <- cmdstan_model("gp_drift_model.stan")

# Fit the model
fit <- mod$sample(
  data = stan_data,
  seed = 123,
  chains = 4,
  iter_warmup = 500,
  iter_sampling = 1000,
  parallel_chains = 4,
  refresh = 100
)

# Extract posterior summaries
fit$print()

# Extract posterior draws for prediction
posterior <- fit$draws()
beta0_hat <- mean(as.numeric(posterior[,"beta0"]))
beta1_hat <- mean(as.numeric(posterior[,"beta1"]))

# Posterior mean for drift
mu_pred <- beta0_hat + beta1_hat * sim_df$Time_scaled

# Plot (base R or ggplot2)
plot(sim_df$Date, sim_df$Sim_Close, type = "l", col = "darkgreen", lwd = 2,
     main = "Stan GP with Drift (cmdstanr)", xlab = "Date", ylab = "Simulated Close Price")
lines(sim_df$Date, mu_pred, col = "blue", lwd = 2)
legend("topleft", legend = c("Simulated", "Posterior Mean (Drift+GP)"),
       col = c("darkgreen", "blue"), lwd = 2)

```
